# Ch11. 동적 계획법

### 동적 계획법(Dynamic Programming)

<br>

동적 계획법이란, 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 의미한다. 이것을 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간을 내어 풀 때 사용한다.

<br>

> **코딩 테스트에서의 DP**

    코딩 테스트의 단골 문제로 출제되고 있기에 필수적으로 알아야하는 개념 중 하나이다.

    간혹 제약사항에 주어지는 숫자의 범위가 크고, 경우의 수가 엄청 많은 문제들이 대부분 DP를 활용하여 풀어야 하는 문제이다.

<br>

### 동적 계획법 방법

모든 작은 문제들은 한 번만 풀어야 한다. 따라서 정답을 구한 작은 문제의 답은 어딘가에 메모해놓는다. 다시 그 보다 큰 문제를 풀어나갈 때, 똑같은 작은 문제가 나타나면 앞서 메모한 작은 문제에 대한 결과값을 이용하는 것이 DP이다.

즉, **상향식 접근법** 으로 가장 작은 부분의 해답을 구한 뒤 이를 저장하고, 저장한 값을 이용하여 상위 문제를 풀어가는 방식이라고 하면 되겠다. 이때 동적 계획의 핵심은 `Memoization(메모이제이션)` 이라는 기법이다.

<br>

### 동적 계획법의 핵심 이론

1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP테이블에 저장하며 추우 재사용할 때는 이 DP테이블을 이용한다. 이를 메모이제이션 기법 이라고 한다
4. 동적 계획법은 톱-다운 방식과 바텀-업 방식으로 구현할 수 있다.

<br>

### 동적 계획법 조건

1. 부분 반복 문제(Overlapping Subproblem)
2. 최적 부분 구조(Optimal Substructure)

```java
**피보나치 수열 공식**
D[N] = D[N-1] + D[N-2];
```

<br>

### 부분 반복 문제(Overlapping Subproblem)

피보나치 수열은 대표적인 재귀함수로, 다음과 같이 표현할 수 있다.

```java
public static int F(int n) {
    if (n <= 2)
        return 1;
    else
        return F(n - 1) + F(n - 2);
}
```

만약, fibo(7) 을 구하는 과정을 도식화해보면 **이진 트리**와 같은 모양이 된다.

7번째 값을 구하기 위해서는 총 25번의 함수가 호출된다는 것을 알 수 있다. 이 과정에서 fibo(5), fibo(4), fibo(3)들이 이미 진행했던 연산임에도 불구하고 재귀되며 반복적으로 연산하게 된다.

이러한 반복적인 연산을 **부분 반복 문제** 라고 한다. 이는 어떤 문제가 여러개의 부분 문제로 쪼개질 수 있을 때 사용하는 용어이다.

<br>

### 최적 부분 구조(Optimal Substructure)

최적 부분 구조란, **작은 부분 문제에서 구한 최적의 답으로 합쳐진 큰 문제의 최적의 답을 구할 수 있어야한다.** 는 것이다.

<br>

### 메모이제이션(Memoization)

메모이제이션은 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, **이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거**하여 프로그램의 실행 속도를 빠르게 하는 기술이다. 부분 문제를 풀었을 때, 해당 문제를 DP테이블에 저장해놓고 다음에 같은 문제가 나왔을 때 다시 계산하지 않고 DP 테이블의 값을 이용할 수 있다.

이러한 방식을 사용하면 불필요한 연산과 탐색이 줄어들어 시간 복잡도 측면에서 많은 이점을 가질 수 있다.

<br>

### 동적계획법의 2가지 접근 방법

- Bottom - up
  가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해나가는 방식으로 반복문의 형태로 구현한다.
- Top - down
  위에서부터 문제를 파악해 내려오는 방식으로 재귀함수 형태로 코드를 구현한다. 가독성이 좋고 이해하기가 편하다는 장점이 있다.

<br>

두 방식 중 좀 더 안전한 방식은 바텀-업 방식으로 톱-다운 방식은 재귀 함수의 형태로 구현돼있기 때문에 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 발생할 수 있다.

<!--
- 예제

[1463 - 정수를 1로 만들기](https://www.notion.so/1463-1-69516c5131104a4faf96a7a68f45d845?pvs=21)

[14501 - 퇴사 준비하기](https://www.notion.so/14501-5fafaa8506c34461a0b7cd282540826a?pvs=21)

[2193 - 이친수 구하기](https://www.notion.so/2193-c524a6f9f48c415e9b29e124447a4ae5?pvs=21)

[10844 - 쉬운 계단 수](https://www.notion.so/10844-0ad54b56d0b546dfbe6bda2c9883b839?pvs=21) -->
